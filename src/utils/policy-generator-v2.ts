export function generatePolicyDocumentV2(complianceData: any): string {
  const metadata = complianceData.metadata;
  const modules = complianceData.modules;
  
  // Determine if this is a jurisdiction-specific template
  const isJurisdictionTemplate = metadata.jurisdiction && metadata.regulation_framework;
  
  // Build the header
  let document = '';
  
  if (isJurisdictionTemplate) {
    document = `# ${metadata.jurisdiction} Compliance Policy

## Regulatory Framework: ${metadata.regulation_framework}

**Document Version:** ${complianceData.version}  
**Last Updated:** ${metadata.last_updated || new Date().toISOString().split('T')[0]}  
**Generated:** ${new Date().toISOString()}

`;

    // Add references if available
    if (metadata.references && metadata.references.length > 0) {
      document += `### Regulatory References\n\n`;
      metadata.references.forEach((ref: string) => {
        document += `- ${ref}\n`;
      });
      document += '\n';
    }
  } else {
    // Generic template
    document = `# ${metadata.project_name || 'Compliance Policy'}

## ${metadata.description || 'Compliance Rules and Requirements'}

**Document Version:** ${complianceData.version}  
**Created Date:** ${metadata.created_date || new Date().toISOString().split('T')[0]}  
**Generated:** ${new Date().toISOString()}

`;
  }

  // Process each module
  for (const [moduleName, moduleData] of Object.entries(modules)) {
    document += generateModuleSection(moduleName, moduleData);
  }

  // Add footer
  document += `
## Compliance Verification

All compliance rules are enforced through:

1. **Smart Contract Enforcement:** Automated validation of all transactions
2. **Oracle Integration:** Real-time KYC/AML verification through Sumsub
3. **Audit Trail:** Complete record of all compliance checks

### Important Notice

This document represents the compliance rules as encoded in the smart contract. 
Any modifications to these rules require updating the source compliance specification 
and redeploying the contracts.

*Generated by Shor Compliance Framework*
`;

  return document;
}

function generateModuleSection(moduleName: string, moduleData: any): string {
  let section = `\n## ${formatModuleName(moduleName)}\n\n`;

  switch (moduleName) {
    case 'token_sale':
      section += generateTokenSaleSection(moduleData);
      break;
    case 'investor_verification':
      section += generateInvestorVerificationSection(moduleData);
      break;
    case 'securities_exemptions':
      section += generateSecuritiesExemptionsSection(moduleData);
      break;
    case 'reporting_requirements':
      section += generateReportingSection(moduleData);
      break;
    case 'marketing_restrictions':
      section += generateMarketingSection(moduleData);
      break;
    case 'resale_restrictions':
      section += generateResaleSection(moduleData);
      break;
    default:
      section += generateGenericSection(moduleData);
  }

  return section;
}

function generateTokenSaleSection(data: any): string {
  let section = '';

  // Sale parameters
  if (data.start_date || data.end_date) {
    section += `### Sale Period\n\n`;
    if (data.start_date) section += `- **Start Date:** ${data.start_date}\n`;
    if (data.end_date) section += `- **End Date:** ${data.end_date}\n`;
    section += '\n';
  }

  // Investment limits
  section += `### Investment Parameters\n\n`;
  if (data.max_cap_usd) {
    section += `- **Maximum Raise:** ${formatCurrency(data.max_cap_usd)}\n`;
  }
  if (data.min_investment_usd) {
    section += `- **Minimum Investment:** ${formatCurrency(data.min_investment_usd)}\n`;
  }
  if (data.kyc_threshold_usd !== undefined) {
    section += `- **KYC Required:** ${data.kyc_threshold_usd === 0 ? 'For all participants' : `Above ${formatCurrency(data.kyc_threshold_usd)}`}\n`;
  }
  if (data.accredited_only) {
    section += `- **Investor Type:** Accredited investors only\n`;
  }
  section += '\n';

  // Geographic restrictions
  if (data.blocklist || data.whitelist) {
    section += `### Geographic Restrictions\n\n`;
    if (data.blocklist && data.blocklist.length > 0) {
      section += `**Prohibited Jurisdictions:**\n`;
      data.blocklist.forEach((country: string) => {
        section += `- ${country}\n`;
      });
    }
    if (data.whitelist && data.whitelist.length > 0) {
      section += `\n**Permitted Jurisdictions:**\n`;
      data.whitelist.forEach((country: string) => {
        section += `- ${country}\n`;
      });
    }
    section += '\n';
  }

  // Additional requirements
  if (data.required_disclosures) {
    section += `### Required Disclosures\n\n`;
    data.required_disclosures.forEach((disclosure: string) => {
      section += `- ${formatFieldName(disclosure)}\n`;
    });
    section += '\n';
  }

  if (data.lockup_days) {
    section += `### Token Lockup\n\n`;
    section += `Tokens are subject to a **${data.lockup_days}-day** lockup period.\n\n`;
  }

  return section;
}

function generateInvestorVerificationSection(data: any): string {
  let section = '';

  if (data.accredited_verification_required) {
    section += `### Accredited Investor Verification\n\n`;
    section += `All investors must provide proof of accredited status through one of the following methods:\n\n`;
    
    if (data.acceptable_verification_methods) {
      data.acceptable_verification_methods.forEach((method: string) => {
        section += `- ${formatFieldName(method)}\n`;
      });
    }
    section += '\n';
  }

  if (data.bad_actor_check_required) {
    section += `### Bad Actor Checks\n\n`;
    section += `All participants are subject to bad actor disqualification checks as required by SEC Rule 506(d).\n\n`;
  }

  return section;
}

function generateSecuritiesExemptionsSection(data: any): string {
  let section = '';

  if (data.primary_exemption) {
    section += `### Primary Exemption\n\n`;
    section += `This offering is conducted under **${data.primary_exemption}**.\n\n`;
  }

  if (data.alternative_exemptions && data.alternative_exemptions.length > 0) {
    section += `### Alternative Exemptions\n\n`;
    section += `The following alternative exemptions may be available:\n\n`;
    data.alternative_exemptions.forEach((exemption: string) => {
      section += `- ${formatFieldName(exemption)}\n`;
    });
    section += '\n';
  }

  return section;
}

function generateReportingSection(data: any): string {
  let section = '';

  if (data.form_d_filing) {
    section += `### SEC Filing Requirements\n\n`;
    section += `- **Form D Filing Required:** Yes\n`;
    if (data.form_d_deadline_days) {
      section += `- **Filing Deadline:** Within ${data.form_d_deadline_days} days of first sale\n`;
    }
    section += '\n';
  }

  if (data.ongoing_reporting !== undefined) {
    section += `### Ongoing Reporting\n\n`;
    section += `- **Periodic Reports Required:** ${data.ongoing_reporting ? 'Yes' : 'No'}\n\n`;
  }

  return section;
}

function generateMarketingSection(data: any): string {
  let section = '';

  if (data.general_solicitation_allowed !== undefined) {
    section += `### Marketing Guidelines\n\n`;
    section += `- **General Solicitation:** ${data.general_solicitation_allowed ? 'Permitted' : 'Prohibited'}\n\n`;
  }

  if (data.disclaimer_text) {
    section += `### Required Disclaimer\n\n`;
    section += `All marketing materials must include the following disclaimer:\n\n`;
    section += `> ${data.disclaimer_text}\n\n`;
  }

  if (data.prohibited_terms && data.prohibited_terms.length > 0) {
    section += `### Prohibited Marketing Terms\n\n`;
    section += `The following terms must not be used in any marketing materials:\n\n`;
    data.prohibited_terms.forEach((term: string) => {
      section += `- "${term}"\n`;
    });
    section += '\n';
  }

  return section;
}

function generateResaleSection(data: any): string {
  let section = '';

  if (data.restricted_period_days) {
    section += `### Resale Restrictions\n\n`;
    section += `- **Restricted Period:** ${data.restricted_period_days} days\n`;
  }
  
  if (data.legend_required) {
    section += `- **Restrictive Legend Required:** Yes\n`;
  }
  
  if (data.transfer_agent_required) {
    section += `- **Transfer Agent Required:** Yes\n`;
  }

  section += '\n';
  return section;
}

function generateGenericSection(data: any): string {
  let section = '';
  
  for (const [key, value] of Object.entries(data)) {
    section += `### ${formatFieldName(key)}\n\n`;
    
    if (Array.isArray(value)) {
      value.forEach((item: any) => {
        section += `- ${item}\n`;
      });
    } else if (typeof value === 'object' && value !== null) {
      for (const [subKey, subValue] of Object.entries(value)) {
        section += `- **${formatFieldName(subKey)}:** ${subValue}\n`;
      }
    } else {
      section += `${value}\n`;
    }
    section += '\n';
  }
  
  return section;
}

// Helper functions
function formatModuleName(name: string): string {
  return name
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function formatFieldName(name: string): string {
  return name
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    maximumFractionDigits: 0
  }).format(amount);
}